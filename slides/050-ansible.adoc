== Ansible

[.notes]
****
Now, let's discuss the solution I've chosen. Ansible is a python automation tool to provision and configure server. It can act on hundred of distant servers to apply configuration or, what will be interesting for us, one local workstation.

Ansible has a notion of roles and playbook we'll talk about in the next slides. It also has a huge community we can rely on.

Whether you like it or hate it, it is easy to read, using a YAML syntax.
****

=== How to use it?

image::tell_me_more.gif[alt='Tell me more',width=80%]


[.notes]
****
So I've told about the solution I've chosen. But how to use it ? We'll see the structure of an Ansible playbooks/roles and how I use it to provision my workstation.
****

=== Structure

[%linenums,text]
----
├── playbooks
│   ├── personal
│   ├── work
│   ├── ├── main.yaml
├── roles
│   ├── jetbrains_toolbox
│   │   ├── defaults
│   │   ├── tasks
│   │── git_config
│   │   ├── tasks
│   └── [...]
----

[.notes]
****
First, if we look at this filetree, we can see that the roles folder contains different local roles, to achieve related tasks, such as anything concerning my git configuration (key signing, global configuration...) or install the jetbrains toolbox.

Then we can find the playbook directory that contains one folder per workstation

****
=== Playbook

[%linenums,yaml]
----
- hosts: localhost
  tasks:
    - name: "Simple task"
      debug:
        msg: |-
include::../code/public_data.txt[]
  roles:
    - role: geerlingguy.docker
      become: true
    - role: git_config
----

[.notes]
****
What is included in a playbook ? It runs on a host , here localhost.

We can find an array of 'tasks' that contains different tasks. A task should always be named after what it does, and call a module, in this example the "debug" module with optional attributes depending on the called module. Here, we can see that I call my debug module with a msg attribute.

We then see an array of roles, that can either come from a local role, such as my git_config we've seen before, a from the ansible community, such as the docker role.

The become flag here is to perform superuser related tasks.

****

=== Usage

[%linenums,bash,highlight=1-3|4-5|6-9]
----
$ cat scripts/setup.sh
python3 -m pip install --user -r "requirements.txt"
ansible-galaxy role install -r "requirements.yml"
$ cat requirements.txt
ansible==7.0.0
$ cat requirements.yml
roles:
  - src: geerlingguy.docker
    version: 6.1.0
----

[.notes]
****
Let's see how to apply this configuration on my workstation. First, we'll need to install the Python dependencies.

Then we can install the community related roles stored on ansible galaxy with the ansible-galaxy command provided by the ansible package. To do so, we can declare these in a requirements.yml file that contains an array of roles and their associated versions, here the 6.1 version for docker.
****

=== Usage

[%linenums,bash]
----
$ ansible-playbook playbooks/personal/main.yaml -K
BECOME password:
----

[%linenums,text]
----
PLAY [localhost] ************************************

TASK [git_config : Ensure Git config file exists] ************************************
ok: [localhost]

TASK [git_config : Render Git config Template] ************************************
changed: [localhost]

PLAY RECAP ************************************
localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0

Playbook run took 0 days, 0 hours, 0 minutes, 1 seconds
----

[.notes]
****
Our dependencies are installed, we are ready to go and can run ansible to configure our laptop.

Ansible offer an ansible-playbook command to run a playbook, with the playbook name as parameter. The flag - (dash) K is used to provide the superuser password to perform superuser tasks when needed.

If we now look at the output ansible provide us, we can see it performs two tasks, but only one changed. Ansible is idempotent, which means it won't retry a task if it does not need modification. In this example, the Git config file already exist so Ansible did nothing. If your file is already configured as it should, ansible will do nothing and just tells you everything is OK and move on to the next task. This mean that, in theory, if you replay the same ansible-playbook command twice, the second time, no modification should occur.

****

=== Software installation

[%linenums,yaml]
.roles/commons/defaults/main.yaml
----
packages_to_install:
  - vim
  - firefox
  - code
----

[%linenums,yaml]
.roles/commons/tasks/main.yaml
----
- name: Install packages
  become: true
  ansible.builtin.package:
    name: "{{ packages_to_install }}"
    state: present
----

[%linenums,yaml]
.playbooks/personal/main.yaml
----
- hosts: localhost
  roles:
    - role: commons
      vars:
        packages_to_install: [vim, firefox]
----

[.notes]
****
Now, let's see a few ansible module that can come in handy to configure our workstation.

The first one is the "package" module to install software. We give to this module a list of desired software, using a variable, here containing vim, firefox and vscode by default, and ansible will ensure these package are installed on this workstation. Obviously, this requires administrator privileges.

One interesting argument we can give to this module is the "state". By default, it ensures that software is present on the workstation, but we can also define a task where we want to ensure that software is absent. This can be useful if you want to uninstall default software that you don't use.

You can use variable to install different software on your personal and professional workstation. To do so, one way is to override the "package_to_install", defined in the role folder.

Let's assume that I need vscode, firefox and vim in my professional workstation. I don't need to override its value and will use the default one. However, on my personal workstation, I don't need vscode and will therefore override the variable value in my personal playbook to only install firefox and vim

****

=== Symlink

[%linenums,text]
----
roles/symlink
├── files
│   ├── .config
│   │   ├── htop
│   │   │   └── htoprc
│   └── .vimrc
----

[%linenums,yaml,highlight=7-11]
.roles/symlink/tasks/main.yaml
----
---

# item = .vimrc
# [...] Create folders
# [...] Ensure file does not exists

- name: "{{ item }} : Update dotfile symlink"
  file:
    src: "{{ role_path }}/files/{{ item }}"
    dest: ~/{{ item }}
    state: link
----

[.notes]
****
This role reproduce the behavior of stow by creating symlink of a set of files on my home directory. We can see that I have a symlink role that contains a folder named files, where I store all my dotfiles configuration.

I then have a tasks that will loop over these files, and foreach one, will call the file module with a state attribute value of link, to create a symlink.

I can now edit my dotfiles as usual since it is symlinked, and just have to review changes in my git repository, commit and push them.
****

=== Templating

[%linenums,yaml]
----
- name: Template gitconfig
  ansible.builtin.template:
    src: templates/gitconfig.j2
    dest: "~/.gitconfig"
----

[%linenums,ini]
.roles/git_config/templates/gitconfig.j2
----
[user]
{% if git_config_user is defined %}
  name = {{ git_config_user }}
{% endif %}
{% if git_config_email is defined %}
  email = {{ git_config_email }}
{% endif %}
----

<https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html>

[.notes]
****
Sadly, symlink is not always an option, you may have some files that requires dedicated configuration to be functional. A classic example is my gitconfig file, where I have my name/email that is different in my professional and personal workstation. Thankfully, Ansible offers a templating system with loop, variables and many others options, using Jinja2 as template engine, so we can use it to template our file with custom values.

You can look into the ansible documentation to deep dive into the possibility this module offers.
****

=== Secrets

[%linenums,yaml]
----
- name: "Copy secret file"
  copy:
    src: "secret_data.txt"
    dest: ~/secret_data.txt
    mode: "0600"
----

[.notes]
****
Now, we sometime need to copy secrets in a dedicated location in our workstation, like a token value to authenticate against a private registry.

If we look at this task, we could believe we put the plaintext version of this secret file into our git repository. However, we'll see that this is not the case.
****

=== Secrets

[%linenums,bash]
----
include::../code/secret_data.txt[]
----

[.notes]
****
As we can see, we only stored an encrypted version of our secret in the git repo and ansible transparently decrypted the secret when needed. This is done with a dedicated ansible tool : ansible-vault. Now we'll see how to use it with our playbook
****

=== Secrets

[%linenums,shell,highlight=1|2-4|5]
----
ansible-vault create secret_data.txt
$ ansible-vault view secret_data.txt
Vault password:
include::../code/public_data.txt[]
$ ansible-playbook playbooks/work/main.yaml --ask-vault-pass
----

[.notes]
****
First, we need to create a vault where we'll store our secret. Ansible-vault will ask for a password, and you'll have to remember it. To decrypt it, we can use the view option of ansible vault.

To use it in a playbook, we need to provide the "--ask-vault-pass" which will ask for the vault password at startup, and ansible will internally decrypt our file when needed with this password.

For those wondering, the password is :
include::../code/password_file[]
****

=== Many workstation?

[%linenums,text]
----
├── personal
│   ├── main.yaml
└── work
    └── main.yaml
----

[.notes]
****
As we saw before, a playbook is a combination of roles and tasks with custom variable. Therefore, to manage multiple workstation, we just have to create a new playbook and use needed roles and/or override variable values.
****

=== What else? ☕

image::battery_off.png[alt='Indicateur batterie off']

[.fragment]
--
[%linenums,yaml]
----
- name: Display battery percentage
  dconf:
    key: "/org/gnome/desktop/interface/show-battery-percentage"
    value: "true"
    state: present
----

image::battery_on.png[alt='Indicateur batterie on']

Windows (regedit) : link:https://docs.ansible.com/ansible/latest/collections/ansible/windows/win_regedit_module.html[win_regedit_module]
--

[.notes]
****
Before closing this part, I'd like to give you another example of what you can do. I personally like to know the percentage value of my battery, however, by default with gnome, this looks like this. However, we can use dconf editor to edit the value of this parameter and toggle the value. This is also possible with ansible, as pointed by this task where we update a key to display battery percentage.

Windows users can also play with regedit values by using the dedicated module, see the docs here.

****

=== Pros and Cons

[%autowidth.stretch,cols="1,1"]
|===
|Goal | State
|Manage configuration files
|✅
|Manage installed software
|✅
|Version Control
|✅
|Maintainability
|✅
|Manage personal and pro workstation
|✅
|Can handle secrets
|✅
|===

[.notes]
****
To put it in a nutshell, ansible has my back on all of my needs, with a few prerequisites. I'm able to manage my dotfiles and installed software, in an easy way with YAML syntax. I can also review changes quite easily and adding a new software or configuration file doesn't take much time. I'm able to manage my personal and pro workstation with dedicated playbooks, reusing roles for most of my needs. I'm also able to handle secret with vault to store my secrets safely.

****

=== What if...

https://docs.ansible.com/

https://galaxy.ansible.com/

[.notes]
****
If you need to do further configuration, I invite you to look at the documentation and existing roles in the Ansible galaxy community. There is probably a role that already fit your needs, and you can reuse / contribute to it without having to reinvent the wheel.
****
